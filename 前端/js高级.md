![](https://ftp.bmp.ovh/imgs/2020/11/cf588cb5a3c099a7.png)
## 1.JSON
JSON(JavaScript Object Notation)

JSON就是一个特殊格式的字符串，可以被任意语言识别，可以转换为任意语言中的对象，JSON主要用来做数据的交互。

JS中的对象只有JS自己认识

JSON和JS对象的格式一样，只不过JSON字符串中的属性名必须加双引号

JSON分类	 1.对象{ } 2.数组[ ]

JSON中允许的值：1.字符串 2.数值 3.布尔值 4.null 5.对象 6.数组

JSON字符串转换为JS对象，JS中提供一个工具类JSON，可以使两者相互转换

**JSON.parse(json)**    将json转换为JS对象

**JSON.stringify(obj)**   将obj转换为JSON字符串

eval()函数	

用来执行一段字符串形式的JS代码，返回执行结果，如果eval()执行的字符串中含有{}，会将{}当成代码块，如果不希望当成代码块解析，在字符串前加一个( ，后加一个 )，功能强大，开发中尽量不使用，执行性能差，具有安全隐患。

JSON如果要兼容IE7及以下版本，引入一个外部js文件

## 2.数据类型
**typeof**  	 

返回数据类型的字符串表达式

可以判断undefined/数值/字符串/布尔值/function

typeof null返回Object，不能判断null与object   object与array

**instanceof**	 

判断对象的具体类型,判断a是不是b的实例

**===**			 

可以判断null、undefined

**相关问题**

1.undefined与null区别

undefined ：定义未赋值

null：定义并赋值为null

2.什么时候赋值为null

var b=null; 表明将要赋值为对象，最后赋值为null使b指向的对象垃圾回收

3.严格区分变量类型和数据类型

数据类型：基本类型、对象类型。

变量类型(变量内存值的类型)：基本类型：保存基本类型的数据、引用类型：保存的地址值


## 3.数据、变量、内存
**数据**

存储在内存中代表特定信息的‘东西’，本质是二进制数

数据的特点：可传递、可运算

一切皆数据，内存中所有操作的目标：数据

算术运算、逻辑运算、赋值运算、运行函数

**内存**

内存条通电后产生的可储存数据的空间（临时的）

一块内存的两个数据：内部存储的数据、地址值

内存分类：

栈：全局变量/局部变量

堆：对象

**变量**
可变化的量，由变量名、变量值组成

每个变量都对应一块小内存，变量名用来查找对应的内存，变量值是内存中保存的数据

**三者关系**

内存用来存储数据的空间，变量是内存的标识

**相关问题**

1.var a=xxx, a内存中保存的是什么？

xxx是基本类型，保存是这个数据

xxx是对象，保存的是对象的地址值

xxx是一个变量，保存的xxx的内存内容(可能是基本数据、地址值)

2.引用变量赋值问题

2个引用变量指向同一个对象，通过一个变量修改内部数据，另一个变量看到的是修改后的数据

2个引用变量指向同一个对象，其中一个引用变量指向另一个对象，另一个引用变量依然指向前一个对象

3.js调用函数时传递变量参数时，是值传递还是引用传递

都是值(基本/地址值)传递

可能是值传递，也可能是引用传递(地址值)

4.js引擎如何管理内存

(1)内存生命周期

分配小内存空间，得到使用权

存储数据，可以反复进行操作

释放小内存空间

(2)释放内存

局部变量：函数执行完自动释放

对象：称为垃圾对象,由垃圾回收器回收

## 4.对象

**对象**

多个数据的封装体，用来保存多个数据的容器。

**为什么要用对象？**

统一管理多个数据

**对象的组成**

属性：属性名(字符串)和属性值(任意类型)组成

方法：一种特别的属性，属性值是函数

**访问对象内部数据**

.属性名          编码简单，有时不能用

['属性名']		编码麻烦，通用

**什么时候必须使用['属性名']？**

1.属性名包含特殊字符：- 空格

2.属性名不确定		为变量

## 5.函数

**函数**

实现特定功能的n条语句的封装体

只有函数是可以执行的，其他类型的数据不能执行

**为什么使用函数**

提高代码复用

便于阅读交流

**如何定义函数**

函数声明

表达式

**如何调用/执行函数**

test()		直接调用

obj.test() 	通过对象调用

new test() 	new调用

test.call/apply(obj)  临时让test成为obj的方法进行调用

## 6.回调函数

**什么函数是回调函数**

1.你定义的

2.你没有调用

3.但是最终执行了

**常见的回调函数**

dom事件回调函数

定时器回调函数

ajax请求回调函数

生命周期回调函数

## 7.IIFE

Immediately-Invoked Function Expression  匿名函数自调用

**作用**

隐藏实现

不会污染外部(全局)命名空间

编码js模板

## 8.this

**this是什么？**

任何函数本质上都是通过某个对象来调用，没有直接指定就是window

所有函数内部都有一个变量this，它的值是调用函数的当前对象

**如何确定this的值？**

test()		：window

p.test()	：	p

new test()	：新创建的对象

p.call(obj)	：obj

## 9.语句分号问题
以下情况不加分号会有问题：

1.小括号开头的前一条语句 

2.中括号开头的前一条语句

解决办法：在行首加分号

---

## 10.函数的prototype

每个函数都有一个prototype属性，它默认指向一个Object空对象(称为：原型对象)

原型对象中有一个属性constructor，它指向函数对象

**显示原型与隐式原型**

每个函数都有一个prototype，即显示原型

每个实例对象都有一个__proto__，即隐式原型

对象的隐式原型的值为其对应构造函数的显示原型的值

函数的prototype属性：定义函数时自动添加，默认值是一个空Object对象

对象的__proto__属性：创建对象时自动添加，默认值为构造函数的prototype属性值

程序员能直接操作显示原型，但不能直接操作隐式原型

## 11.原型链

![](https://ftp.bmp.ovh/imgs/2020/09/e88d8b02dc8be1b3.png)

访问一个对象的属性时，先在自身属性中查找，找到返回

如果没有，沿着__proto__这条链向上查找，找到返回

如果最终没有找到，返回undefined

别名：隐式原型链

作用：查找对象的属性

所有函数的__proto__都是一样的

函数的显示原型指向的对象默认是空Object实例对象(Object不是)

所有函数都是Function的实例(包含Function)

Object的原型对象是原型链尽头

**原型链属性问题**

读取对象属性值时，会自动到原型链中查找

设置对象属性值时，不会查找原型链，如果当前对象没有此属性，直接添加此属性并设置其值

方法一般定义在原型中，属性一般通过构造函数定义在对象本身上

**instanceof**

A instanceof B

如果B函数的显示原型对象在A对象的原型链上，返回true

---

## 12.变量提升与函数提升

**变量声明提升**

通过var定义的变量，在定义语句之前就可以访问到

值：undefined

**函数声明提升**

通过function声明的函数，在之前就可以直接调用

值：函数定义(对象)

## 13.执行上下文

**代码分类**

全局代码

函数(局部)代码

**全局执行上下文**

1.执行全局代码前将window确定为全局执行上下文

2.对全局数据进行预处理

+ var定义的全局变量  赋值为undefined，添加为window的属性
+ function声明的全局函数 赋值fun，添加为window 的方法
+ this 赋值为window

3.开始执行全局代码

**函数执行上下文**

1.在调用函数、执行函数体之前，创建函数执行上下文对象

2.对局部数据进行预处理

+ 形参变量 赋值为实参，添加为执行上下文的属性
+ arguments 赋值为实参列表，添加为执行上下文的属性
+ var定义的局部变量  赋值为undefined，添加为执行上下文的属性
+ function声明的函数 赋值fun，添加为执行上下文 的方法
+ this 赋值为调用函数的对象

3.开始执行函数体代码

**执行上下文栈**

在全局代码执行前，JS引擎就会创建一个栈来存储管理所有的执行上下文对象

## 14.作用域与作用域链

一个代码所在的区域，静态的，在编写代码时就确定了

**分类**	
	
全局作用域
	
函数作用域
	
没有块作用域

**作用**		

隔离变量，不同作用域下同名变量不会有冲突

---

## 15.闭包

**如何产生闭包**

当一个嵌套的内部函数引用了嵌套的外部函数的变量时，就产生了闭包

**闭包是什么**

闭包是嵌套的内部函数

**产生闭包的条件**

+ 函数嵌套
+ 内部函数引用外部函数的数据(变量/函数)
+ 调用外部函数

**常见的闭包**

1.将函数作为另一个函数的返回值
```
function fn1(){
    let a = 1
    function fn2(){
        a++
        console.log(a)
    }
    return fn2
}
```

2.将函数作为实参传递给另一个函数调用
```
function showDelay(msg,time){
    setTimeout(function (){
        alert(msg)
    },time)
}
```

**闭包的作用**

1.使用函数内部的变量在函数执行完后，仍然存活在内存中(延长了局部变量的生命周期)

2.让函数外部可以操作(读写)到函数内部的数据(变量/函数)

**函数执行后，函数内部声明的局部变量是否还存在？**

一般不存在，存在于闭包中的变量才可能存在

**在函数外部能直接访问函数内部的局部变量吗？**

不能，但可以通过闭包让外部操作它

**闭包的生命周期**

产生：在嵌套内部函数定义执行完时就产生了

死亡：在嵌套的内部函数成为垃圾对象时

**闭包的应用**
	  
定义JS模块：具有特定功能的js文件

+ 将所有的数据和功能都封装在一个函数内部
+ 只向外暴露一个包含n个方法的对象或函数
+ 模块的使用者，只需要通过模板暴露的对象调用方法来实现对应的功能

**闭包的缺点**

1.函数执行完后，函数内的局部变量没有释放，占用内存时间会变长

2.容易造成内存泄漏

解决：能不用闭包就不用	及时释放

## 16.内存溢出与内存泄漏

**内存溢出**

当程序运行需要的内存超过了剩余的内存时，就抛出内存溢出的错误

**内存泄漏**

占用的内存没有及时释放，积累多了容易导致内存溢出

**常见的内存泄漏**

+ 意外的全局变量
+ 没有及时清理的计时器或回调函数
+ 闭包

## 17.对象创建模式

1. Object构造函数模式

操作：先创建空Object对象，再动态添加属性/方法

适用场景：起始时不确定对象内部数据

问题：语句太多

2. 对象字面量模式

操作：使用{}创建对象，同时指定属性/方法

使用场景：起始时对象内部数据是确定的

问题：如果创建多个对象，有重复代码

3. 工厂模式

操作：通过工厂函数动态创建对象并返回

适用场景：需要创建多个对象

问题：对象没有一个具体的类型，都是Object类型

4. 自定义构造函数模式

操作：自定义构造函数，通过new创建对象

使用场景：需要创建多个类型确定的对象

问题：每个对象都有相同的数据，浪费内存

5. 构造函数+原型的组合模式

操作：自定义构造函数，属性在函数中初始化，方法添加到原型上

使用场景：需要创建多个类型确定的对象

## 18.原型链继承

子类型的原型为父类型的一个实例对象

让子类型的原型的constructor指向子类型

![](https://ftp.bmp.ovh/imgs/2020/09/f96c4f9f26f9dc9c.jpg)

**组合继承**

原型链+借用构造函数的组合继承

---

## 19.进程与线程

**进程process**

程序的一次执行过程，占有一片独有的内存空间

是系统进行资源分配和调度的一个独立单位

**线程thread**

是进程内的一个独立执行单元，是CPU的最小的调度单元

为了减小程序在并发执行时的时空开销，提升操作系统的并发性能

## 20.定时器

定时器并不能保证真正定时执行

一般会延迟一点(可以接受)，也有可能延迟很长时间

定时器回调函数在主线程执行，js是单线程的

## 21.js是单线程执行

alert暂停当前主线程的执行，同时暂停计时，点击确定后，恢复程序执行和计时

**代码的分类**

初始化代码

回调代码

**js引擎执行代码的基本流程**

先执行初始化代码，包含一些特别的代码	回调函数(异步执行) 

+ 设置定时器
+ 绑定事件监听
+ 发送ajax请求

后面在某个时刻才会执行回调代码

## 22.事件循环模型
![](https://ftp.bmp.ovh/imgs/2020/09/b1437548e44d16c7.jpg)

**2个重要组成部分：**

事件(定时器/DOM事件/Ajax)管理模块

回调队列

## 23.Web Workers

可将一些大计算量的代码交由web worker运行而不冻结用户界面

alert是window的方法，在分线程不能使用

分线程中的全局对象不是window
